<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>mskTile</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// directions
enum d {LEFT = -1, RIGHT = 1, UP = -2, DOWN = 2}

// states
enum s {IDLE, WALK, JUMP, JUMP2, SHOOT, POP, SWIM, DEAD, BUBBLE, TOSS, HURT}

// weather
enum w { NONE, RAIN, SNOW, WIND, DARKNESS }

// ground: same move animation as player
// rotatewalk: same as ground but rotates with angle
// float: no rotation, no walk animation
// rotatefloat: rotation, no walk animation
// spin: constantly turning the angle
enum m { WALK = 0, ROTATEWALK = 1, FLOAT = 2, ROTATEFLOAT = 3, SPIN = 4 }

// abilities
enum a { NONE = 0, EARTH = 1, THUNDER = 2, SUN = 4, SKY = 8 }

randomize();
global.TW = background_get_width(sprTiles) / T;

global.font = font_add_sprite(sprFont, ord(' '), true, 1);
display_set_gui_size(WIDTH, HEIGHT);

global.maxScales = 0;
map1 = importLevel("map1.tmx");
global.ds_rooms = ds_grid_create(0,0);

// save/load vars

global.bubbles = 0;
global.scales = 0;
global.ds_bubbles = ds_list_create();
global.ds_scales = ds_list_create();
global.ds_keys = ds_list_create();
global.ds_keyblocks = ds_list_create();
global.ds_gates = ds_list_create();
global.ds_bosses = ds_list_create();
global.ds_teleporters = ds_list_create();

global.hasKey = false;
global.spawn_x = -1;
global.spawn_y = -1;
global.spawn_dir = d.LEFT;
global.bg = -1;
global.weather = w.NONE;
global.ability = a.NONE;

// input vars

global.k_left = 0;
global.k_right = 0;
global.k_up = 0;
global.k_action = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(keyboard_check_pressed(ord('R'))) room_restart();
if(keyboard_check_pressed(ord('Q'))) game_restart();
if(keyboard_check_pressed(ord('C'))) file_delete("save.dat");
if(keyboard_check_pressed(ord('K'))) {
    ds_list_clear(global.ds_keys);
    ds_list_clear(global.ds_keyblocks);
    ds_list_clear(global.ds_teleporters);
    global.hasKey = 0;
}
if(keyboard_check_pressed('B')) {
    ds_list_clear(global.ds_bosses);
}
if(keyboard_check_pressed(ord('P'))) {
    objPlayer.x = 2*T;
    objPlayer.y = 2*T;
}
if (keyboard_check_pressed(ord('7'))) {
    c_out("[ability: " + string(global.ability) +"]", hasAbility(a.NONE), 
        hasAbility(a.EARTH),
        hasAbility(a.THUNDER),
        hasAbility(a.SUN),
        hasAbility(a.SKY));
    global.ability++;
}

if (mouse_check_button(mb_right)) {
    objPlayer.x = mouse_x;
    objPlayer.y = mouse_y;
}

if (instance_exists(objBoss)) {
    if(keyboard_check_pressed(ord('K'))) {
        objBoss.hp = max(objBoss.hp - 1, 0);
        objBoss2Seg.hp = max(objBoss2Seg.hp - 1, 0);
    }
}

if (keyboard_check_pressed(ord('0'))) {
    save((objPlayer.x div T) * T + 8, (objPlayer.y div T) * T + 8);
}

if (keyboard_check(vk_shift)) {
    objPlayer.xVel = 0;
    objPlayer.yVel -= objPlayer.yGrav;
    
    if (keyboard_check_pressed(vk_left))
        objPlayer.x -= view_wview;        
    if (keyboard_check_pressed(vk_right))
        objPlayer.x += view_wview;        
    if (keyboard_check_pressed(vk_up))
        objPlayer.y -= view_hview;        
    if (keyboard_check_pressed(vk_down))
        objPlayer.y += view_hview;        
    
}

if (keyboard_check(vk_space)) {
    room_speed = 5;
} else {
    room_speed = 60;
}

// input

global.k_left = keyboard_check(vk_left) &amp;&amp; global.keysEnabled;
global.k_right = keyboard_check(vk_right) &amp;&amp; global.keysEnabled;
global.k_up_pressed = keyboard_check_pressed(vk_up) &amp;&amp; global.keysEnabled;
global.k_up = keyboard_check(vk_up) &amp;&amp; global.keysEnabled;
global.k_action_pressed = (keyboard_check_pressed(vk_down)) &amp;&amp; global.keysEnabled;
global.k_action = (keyboard_check(vk_down)) &amp;&amp; global.keysEnabled;
global.k_action_released = (keyboard_check_released(vk_down)) &amp;&amp; global.keysEnabled;

// room lazy-loading

var view_x = ((objCameraTarget.x div WIDTH) * WIDTH) / T;
var view_y = ((objCameraTarget.y div HEIGHT) * HEIGHT) / T;
for(var i = -1; i &lt; 2; i++) {
    for(var j = -1; j &lt; 2; j++) {
        var vx = view_x + i * 16;
        var vy = view_y + j * 9;        
        loadSegment(map1, vx, vy);
    }
}

// shake

global.shakeTimer = max(global.shakeTimer - 1, 0);
if (global.shakeTimer &gt; 0) {
    view_angle = -1 + random(2);
} else {
    view_angle = 0;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// instance management

// particles
instance_activate_object(objParticle);
if (instance_number(objParticle) &gt; 200) {
    var part = instance_find(objParticle, 0);
    if (part) {
        with(part) instance_destroy();
    }
}

// water bubbles
if (instance_number(objWaterBubble) &lt; 25) {
    var water_x = view_xview + random(view_wview);
    var water_y = view_yview + random(view_hview);
    if (tile_layer_find(LAYER_WATER, water_x, water_y) &amp;&amp; !place_meeting((water_x div T) * T, (water_y div T) * T, objSolid)) {
        instance_create(water_x, water_y, objWaterBubble);
    }
}

// any
instance_deactivate_object(objAny);
var _dst = 4*T;
instance_activate_region(view_xview - _dst, view_yview - _dst, view_wview + 2*_dst, view_hview + 2*_dst, 1);

instance_deactivate_object(objBigBlock);
instance_activate_region(view_xview, view_yview, view_wview, view_hview, 1);

instance_activate_object(objFollowKey);
if (instance_number(objFollowKey) &lt; global.hasKey) {
    instance_create(objPlayer.x, objPlayer.y, objFollowKey);
}

instance_activate_object(objAmbience);

global.bubbles = ds_list_size(global.ds_bubbles);
global.scales = ds_list_size(global.ds_scales);
global.timer = (global.timer + 1) % INF;

// switches n stuff

instance_deactivate_object(objSwitchBlock);
instance_activate_region(view_xview - .5*view_wview, view_yview - .5*view_hview, 2*view_wview, 2*view_hview, 1);

global.switchState = 0;
with(objSwitch) state = 0;

with (objBubble) {
    if (hasAbility(a.THUNDER)) {
        if (state == s.IDLE) {
            lightning = 0;
            for(var i = 0; i &lt; instance_number(objSwitch); i++) {
                var sw = instance_find(objSwitch, i);
                if (sw &amp;&amp; point_distance(x, y, sw.x, sw.y) &lt; 4*T) {
                    var px = x;
                    var py = y;
                    var ang = point_direction(x, y, sw.x, sw.y);
                    var col = false;
                    for(var j = 0; j &lt; point_distance(x, y, sw.x, sw.y); j+=2) {
                        px = x + lengthdir_x(j, ang);
                        py = y + lengthdir_y(j, ang);
                        if (collision_point(px, py, objSolid, 0, 1)) {
                            col = true;
                            break;
                        }
                    }
                    if (!col) sw.state = 1;
                    if (sw.state == 1) global.switchState = 1;
                    
                    var rx = x + lengthdir_x(7, ang);
                    var ry = y + lengthdir_y(7, ang);
                    lightning[i] = array(rx, ry, px, py);
                }
            }
        }
    }
}

// darkness/glow
instance_activate_object(objGlow);
with(objTorch) activateGlow();
with(objPickupRune) activateGlow();
with(objPickupKey) activateGlow();
with(objPickupDragonScale) activateGlow();
if(hasAbility(a.SUN)) with(objB) activateGlow();
instance_deactivate_object(objGlow);
instance_activate_region(view_xview - 2*T, view_yview - 2*T, view_wview + 4*T, view_hview + 4*T, 1);

with (objSwitchBlock) {
    if (defaultState != global.switchState) {
        alpha = max(alpha - .1, 0);
        if (alpha == 0)
            instance_deactivate_object(id);
    } else {
        alpha = min(alpha + .1, 1);
    }
    if (collision_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, objPlayer, 0, 1))
        instance_deactivate_object(id);
}

// switchable currents
if(global.switchState == 0) 
    instance_deactivate_object(objSwitchCurrent);

// boss mgmt
instance_activate_object(objBoss);
if (instance_exists(objBoss)) {
    instance_activate_object(objEnemyProjectile);
    instance_activate_object(objBossBlock);
    
    if (instance_exists(objBoss2)) {
        instance_activate_object(objBoss2Seg);
        with(objBoss2) instance_activate_region(x - 2*T, y - 2*T, 4*T, 4*T, 1);
    }
} else {
    instance_deactivate_object(objBossBlock);
}

//
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.timer = 0;
global.switchState = 0;
global.shakeTimer = 0;
global.keysEnabled = true;

// reset room size &amp; reset room grid
var data = map1[0];
var _w = ds_grid_width(data[0]);
var _h = ds_grid_height(data[0]);
if (room_width!=_w*T || room_height!=_h*T)
{
    room_set_width(room,_w*T);
    room_set_height(room,_h*T);
    room_restart();
    exit;
}

load();

// just stores room-wise true/false if visited
ds_grid_destroy(global.ds_rooms);
global.ds_rooms = ds_grid_create((_w*T) div WIDTH, (_h*T) div HEIGHT);

var objects = map1[1];
// objects
for (var i = 0; i &lt; ds_list_size(objects); i++) {
    var obj = ds_list_find_value(objects, i);
    
    var obj_type = ds_map_find_value(obj, "type");
    var obj_x = real(ds_map_find_value(obj, "x"));
    var obj_y = real(ds_map_find_value(obj, "y"));
    
    switch(obj_type) {
        case "player":
            if (global.spawn_x == -1 || global.spawn_y == -1) {
                instance_create(
                    ((obj_x div view_wview) * view_wview) + .5 * view_wview, 
                    ((obj_y div view_hview) * view_hview) + .5 * view_hview, objCamera);
                instance_create(obj_x + 8, obj_y + 8, objPlayerEgg);
            }
            else {
                instance_create(
                    ((global.spawn_x div view_wview) * view_wview) + .5 * view_wview, 
                    ((global.spawn_y div view_hview) * view_hview) + .5 * view_hview, objCamera);
                var o_player = instance_create(global.spawn_x, global.spawn_y, objPlayer);
                o_player.dir = global.spawn_dir;
            }
            var view_x = ((objCameraTarget.x div WIDTH) * WIDTH) / T;
            var view_y = ((objCameraTarget.y div HEIGHT) * HEIGHT) / T;
            loadSegment(map1, view_x, view_y);
        break;
        case "ambience":
            var amb = instance_create(obj_x, obj_y, objAmbience);
            amb.bg = real(ds_map_find_value(obj, "bg"));
            amb.weather = real(ds_map_find_value(obj, "weather"));
            
            // custom room width/height
            var rw = real(ds_map_find_value(obj, "rw"));
            var rh = real(ds_map_find_value(obj, "rh"));
            for (var rwi = 0; rwi &lt; rw; rwi++) {
                for (var rwj = 0; rwj &lt; rh; rwj++) {
                    var bigView = instance_place(amb.x + rwi * view_wview, amb.y + rwj * view_hview, objBigView);
                    if (!instance_exists(bigView))
                        bigView = instance_create(amb.x + rwi * view_wview, amb.y + rwj * view_hview, objBigView);
                    if (rw &gt; 1) bigView.hor = (amb.x + 1) * 100;
                    if (rh &gt; 1) bigView.ver = (amb.y + 1) * 100;
                }
            }
        break;
        case "rune":
            var rune = instance_create(obj_x + 8, obj_y + 8, objPickupRune);
            rune.ability = real(ds_map_find_value(obj, "ability"));
        break;
        case "teleporter":
            var teleporter = instance_create(obj_x - T, obj_y, objTeleporter);
            // if true, doesn't need switch to enable
            teleporter.autoActive = real(ds_map_find_value(obj, "autoActive"));
            // if true, is already warpable
            teleporter.alreadyEnabled = real(ds_map_find_value(obj, "alreadyEnabled"));
            teleporter.identifier = createID(teleporter);            
        break;
        case "boss":
            var bossSpawn = instance_create(obj_x + 8, obj_y + 8, objBossSpawn);
            bossSpawn.boss = real(ds_map_find_value(obj, "boss"));
            bossSpawn.identifier = createID(bossSpawn);
        break;
        case "enemy":
            var e = instance_create(obj_x + 8, obj_y + 8, objEnemy);
            e.type = real(ds_map_find_value(obj, "enemyType"));
            e.shot_delay = real(ds_map_find_value(obj, "shot_delay"));
            e.shot_type = real(ds_map_find_value(obj, "shot_type"));
                        
            // visual move vars
            e.dir = real(ds_map_find_value(obj, "dir"));            
            e.movePattern = real(ds_map_find_value(obj, "movePattern"));
            
            // path offset
            e.x += real(ds_map_find_value(obj, "path_x"));
            e.y += real(ds_map_find_value(obj, "path_y"));

            // path stuff
            e.path_spd = real(ds_map_find_value(obj, "path_speed"));
            e.angle_offset = real(ds_map_find_value(obj, "angle_offset"));
            e.invincible = real(ds_map_find_value(obj, "invincible"));
            e.drawPath = real(ds_map_find_value(obj, "draw_path"));
            var path_str = string(ds_map_find_value(obj, "path"));
            var path_parts = string_split(path_str, "|");
            var path_precision = real(ds_map_find_value(obj, "path_precision"));
            var path_smooth = real(ds_map_find_value(obj, "path_smooth"));
            for(var path_i = 0; path_i &lt; array_length_1d(path_parts); path_i++) {
                var path_p = string_split(path_parts[path_i], ",");
                var px = real(path_p[0]);
                var py = real(path_p[1]);
                var ps = 100;
                if (array_length_1d(path_p) &gt; 2) {
                    ps = real(path_p[2]);
                }
                path_add_point(e.path, px, py, ps);
            }
            path_set_kind(e.path, path_smooth);
            path_set_precision(e.path, path_precision);
            path_set_closed(e.path, real(ds_map_find_value(obj, "path_closed")));
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
